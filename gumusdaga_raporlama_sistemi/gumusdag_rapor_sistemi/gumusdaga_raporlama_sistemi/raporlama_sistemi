# app_fabrika_desktop.py
# -----------------------------------------------------------
# Masaüstü (web tabanlı değil) prototip
# PySide6 (Qt) + SQLite ile tek dosya uygulama
# Çalıştırmadan önce `pip install -r requirements.txt` komutunu uygulayarak
# PySide6 bağımlılığının kurulduğundan emin olun.
# Özellikler (MVP):
#  - 6 üretim bandı için Günlük Üretim kaydı
#  - Duraklama kaydı (toplam dakika + neden/Departman kırılımı tablo ile)
#  - Geçmiş sekmesinde son kayıtları listeleme + temel filtreler
# Not: Bu bir başlangıç iskeletidir; raporlama ve ileri filtreleme basit tutuldu.
# -----------------------------------------------------------

import os
import sys
import sqlite3
from datetime import datetime, date

from PySide6.QtCore import Qt, QDate
from PySide6.QtGui import QAction, QPixmap
from PySide6.QtWidgets import (
    QApplication, QWidget, QMainWindow, QTabWidget, QVBoxLayout, QHBoxLayout,
    QLabel, QComboBox, QDateEdit, QSpinBox, QLineEdit, QTextEdit,
    QPushButton, QTableWidget, QTableWidgetItem, QHeaderView, QMessageBox,
    QGroupBox, QScrollArea, QDialog, QFormLayout, QDialogButtonBox,
    QPlainTextEdit,
)

DB_FILE = "fabrika.db"
LINES = [f"Bant {i}" for i in range(1, 7)]
DEPARTMENTS = ["A - Üretim", "B - Bakım", "C - Kalite", "D - Lojistik"]
REASONS = [
    "A - Kalıp Hatası", "B - Makine Arızası", "C - Malzeme Eksikliği", "D - Operatör Kaynaklı"
]

DEFAULT_USERNAME = "admin"
DEFAULT_PASSWORD = "admin"

LOGO_PATH = os.path.join(os.path.dirname(os.path.abspath(__file__)), "gumusdag_logo.jpeg")


def normalize_reason_department(reason_value, department_value):
    """Return normalized (reason, department, swapped?) tuple for split entries."""
    reason_text = (reason_value or "").strip()
    department_text = (department_value or "").strip()

    reason_is_department = reason_text in DEPARTMENTS
    department_is_department = department_text in DEPARTMENTS
    reason_is_reason = reason_text in REASONS
    department_is_reason = department_text in REASONS

    should_swap = False

    if reason_is_department and not department_is_department:
        should_swap = True
    elif department_is_reason and not reason_is_reason:
        should_swap = True
    elif reason_is_department and department_is_reason:
        should_swap = True

    if should_swap:
        return department_text, reason_text, True

    return reason_text, department_text, False


def remove_duplicate_line_date(conn, table_name):
    """Keep the latest row per (line, date) pair to satisfy upcoming unique index."""
    conn.execute(
        f"""
        DELETE FROM {table_name}
        WHERE id NOT IN (
            SELECT MAX(id)
            FROM {table_name}
            GROUP BY line, date
        )
        """
    )


def normalize_existing_downtime_splits(conn):
    rows = conn.execute(
        "SELECT id, reason, department FROM downtime_splits"
    ).fetchall()

    updates = []
    for row in rows:
        normalized_reason, normalized_department, swapped = normalize_reason_department(
            row["reason"], row["department"]
        )
        if swapped:
            updates.append((normalized_reason, normalized_department, row["id"]))

    if updates:
        conn.executemany(
            "UPDATE downtime_splits SET reason=?, department=? WHERE id=?",
            updates,
        )
        conn.commit()


class LoginDialog(QDialog):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("Giriş Yap")
        self.setModal(True)
        self.setMinimumSize(520, 420)

        layout = QVBoxLayout(self)
        logo_label = QLabel()
        logo_label.setAlignment(Qt.AlignCenter)
        if os.path.exists(LOGO_PATH):
            pixmap = QPixmap(LOGO_PATH)
            if not pixmap.isNull():
                logo_label.setPixmap(
                    pixmap.scaled(
                        280,
                        280,
                        Qt.KeepAspectRatio,
                        Qt.SmoothTransformation,
                    )
                )
        layout.addWidget(logo_label)
        form_layout = QFormLayout()
        form_layout.setSpacing(20)
        form_layout.setLabelAlignment(Qt.AlignLeft)
        layout.addLayout(form_layout)

        self.username_edit = QLineEdit()
        self.username_edit.setPlaceholderText("Kullanıcı adı")
        self.username_edit.setText(DEFAULT_USERNAME)
        self.username_edit.setMinimumHeight(44)
        self.username_edit.setStyleSheet("font-size: 16px; padding: 8px 12px;")
        form_layout.addRow("Kullanıcı Adı", self.username_edit)

        self.password_edit = QLineEdit()
        self.password_edit.setPlaceholderText("Şifre")
        self.password_edit.setEchoMode(QLineEdit.Password)
        self.password_edit.setMinimumHeight(44)
        self.password_edit.setStyleSheet("font-size: 16px; padding: 8px 12px;")
        form_layout.addRow("Şifre", self.password_edit)

        buttons = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
        buttons.accepted.connect(self.handle_login)
        buttons.rejected.connect(self.reject)
        layout.addWidget(buttons)

    def handle_login(self):
        username = self.username_edit.text().strip()
        password = self.password_edit.text()

        if username == DEFAULT_USERNAME and password == DEFAULT_PASSWORD:
            self.accept()
            return

        QMessageBox.warning(self, "Giriş Başarısız", "Kullanıcı adı veya şifre hatalı.")
        self.password_edit.clear()
        self.password_edit.setFocus()

# --------------------- DB Helpers -------------------------

def get_conn():
    conn = sqlite3.connect(DB_FILE)
    conn.row_factory = sqlite3.Row
    return conn


def init_db():
    conn = get_conn()
    cur = conn.cursor()
    cur.execute(
        """
        CREATE TABLE IF NOT EXISTS productions (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            line TEXT NOT NULL,
            date TEXT NOT NULL,
            expected INTEGER NOT NULL,
            actual INTEGER NOT NULL,
            performance_pct REAL NOT NULL,
            comment TEXT,
            created_at TEXT NOT NULL
        )
        """
    )
    remove_duplicate_line_date(conn, "productions")
    cur.execute(
        "CREATE UNIQUE INDEX IF NOT EXISTS idx_productions_line_date ON productions(line, date)"
    )
    cur.execute(
        """
        CREATE TABLE IF NOT EXISTS downtimes (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            line TEXT NOT NULL,
            date TEXT NOT NULL,
            start_time TEXT NOT NULL,
            total_minutes INTEGER NOT NULL,
            comment TEXT,
            created_at TEXT NOT NULL
        )
        """
    )
    remove_duplicate_line_date(conn, "downtimes")
    cur.execute(
        "CREATE UNIQUE INDEX IF NOT EXISTS idx_downtimes_line_date ON downtimes(line, date)"
    )
    cur.execute(
        """
        CREATE TABLE IF NOT EXISTS downtime_splits (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            downtime_id INTEGER NOT NULL,
            reason TEXT NOT NULL,
            department TEXT NOT NULL,
            minutes INTEGER NOT NULL,
            note TEXT,
            FOREIGN KEY (downtime_id) REFERENCES downtimes(id) ON DELETE CASCADE
        )
        """
    )
    conn.commit()
    normalize_existing_downtime_splits(conn)
    conn.close()


# --------------------- UI Widgets -------------------------

class ProductionTab(QWidget):
    def __init__(self):
        super().__init__()

        main_layout = QVBoxLayout(self)
        main_layout.setContentsMargins(12, 12, 12, 12)
        main_layout.setSpacing(16)

        scroll_area = QScrollArea()
        scroll_area.setWidgetResizable(True)
        main_layout.addWidget(scroll_area)

        scroll_content = QWidget()
        scroll_area.setWidget(scroll_content)

        content_layout = QVBoxLayout(scroll_content)
        content_layout.setContentsMargins(4, 4, 4, 4)
        content_layout.setSpacing(16)

        production_group = QGroupBox("Günlük Üretim ve Performans")
        prod_layout = QVBoxLayout(production_group)
        prod_layout.setSpacing(12)
        prod_layout.setContentsMargins(12, 12, 12, 12)

        form = QHBoxLayout()
        form.setSpacing(12)
        self.cmb_line = QComboBox()
        self.cmb_line.addItems(LINES)
        self.cmb_line.currentTextChanged.connect(self.on_line_changed)
        self.date_edit = QDateEdit()
        self.date_edit.setCalendarPopup(True)
        self.date_edit.setDate(QDate.currentDate())
        self.spn_expected = QSpinBox()
        self.spn_expected.setRange(0, 10_000)
        self.spn_expected.setValue(100)
        self.spn_actual = QSpinBox()
        self.spn_actual.setRange(0, 10_000)
        self.spn_actual.setValue(90)
        form.addWidget(QLabel("Bant:"))
        form.addWidget(self.cmb_line)
        form.addWidget(QLabel("Tarih:"))
        form.addWidget(self.date_edit)
        form.addWidget(QLabel("Beklenen:"))
        form.addWidget(self.spn_expected)
        form.addWidget(QLabel("Gerçekleşen:"))
        form.addWidget(self.spn_actual)
        prod_layout.addLayout(form)

        self.txt_comment = QLineEdit()
        self.txt_comment.setPlaceholderText("Yorum (opsiyonel)")
        prod_layout.addWidget(self.txt_comment)

        button_row = QHBoxLayout()
        button_row.setSpacing(8)

        self.btn_save_production = QPushButton("Üretimi Kaydet")
        self.btn_save_production.clicked.connect(self.save_production_record)
        button_row.addWidget(self.btn_save_production)

        self.btn_delete_production = QPushButton("Seçilen Üretimi Sil")
        self.btn_delete_production.clicked.connect(self.delete_selected_production)
        button_row.addWidget(self.btn_delete_production)

        button_row.addStretch()
        prod_layout.addLayout(button_row)

        self.production_tbl = QTableWidget(0, 0)
        self.production_tbl.setWordWrap(False)
        self.production_tbl.setTextElideMode(Qt.ElideRight)
        self.production_tbl.verticalHeader().setDefaultSectionSize(44)
        self.production_tbl.horizontalHeader().setSectionResizeMode(QHeaderView.Stretch)
        self.production_tbl.cellClicked.connect(self.on_production_cell_clicked)
        prod_layout.addWidget(self.production_tbl)

        self.production_detail_box = QGroupBox("Detay Önizleme")
        detail_layout = QVBoxLayout(self.production_detail_box)
        detail_layout.setSpacing(8)
        detail_layout.setContentsMargins(12, 12, 12, 12)
        self.production_detail_title = QLabel()
        self.production_detail_title.setStyleSheet("font-weight: 600;")
        detail_layout.addWidget(self.production_detail_title)
        self.production_detail_view = QPlainTextEdit()
        self.production_detail_view.setReadOnly(True)
        self.production_detail_view.setPlaceholderText(
            "Duraklama veya yorum detayını görmek için tabloda ilgili hücreyi seçin."
        )
        self.production_detail_view.setMinimumHeight(140)
        detail_layout.addWidget(self.production_detail_view)
        prod_layout.addWidget(self.production_detail_box)
        self.clear_production_detail_preview()

        content_layout.addWidget(production_group)

        general_row = QHBoxLayout()
        general_row.setSpacing(12)
        self.ev_cmb_line = QComboBox()
        self.ev_cmb_line.addItems(LINES)
        self.ev_cmb_line.currentTextChanged.connect(self.on_event_line_changed)
        self.ev_date = QDateEdit()
        self.ev_date.setCalendarPopup(True)
        self.ev_date.setDate(QDate.currentDate())
        general_row.addWidget(QLabel("Bant (eşlenik):"))
        general_row.addWidget(self.ev_cmb_line)
        general_row.addWidget(QLabel("Tarih:"))
        general_row.addWidget(self.ev_date)
        general_row.addStretch()
        content_layout.addLayout(general_row)

        self.dt_group = QGroupBox("Duraklama Detayları")
        dt_layout = QVBoxLayout(self.dt_group)
        dt_layout.setSpacing(12)
        dt_layout.setContentsMargins(12, 12, 12, 12)

        row1 = QHBoxLayout()
        row1.setSpacing(12)
        self.dt_start_time = QLineEdit()
        self.dt_start_time.setPlaceholderText("Başlangıç (HH:MM)")
        self.dt_total = QSpinBox()
        self.dt_total.setRange(1, 10_000)
        self.dt_total.setValue(60)
        row1.addWidget(QLabel("Başlangıç:"))
        row1.addWidget(self.dt_start_time)
        row1.addWidget(QLabel("Toplam (dk):"))
        row1.addWidget(self.dt_total)
        dt_layout.addLayout(row1)

        self.dt_tbl_split = QTableWidget(0, 4)
        self.dt_tbl_split.setHorizontalHeaderLabels(["Departman", "Neden", "Dakika", "Not"])
        self.dt_tbl_split.horizontalHeader().setSectionResizeMode(QHeaderView.Stretch)
        self.dt_tbl_split.setMinimumHeight(160)
        dt_layout.addWidget(self.dt_tbl_split)

        split_buttons = QHBoxLayout()
        split_buttons.setSpacing(12)
        btn_add = QPushButton("Satır Ekle")
        btn_add.clicked.connect(self.add_split_row)
        btn_del = QPushButton("Seçili Satırı Sil")
        btn_del.clicked.connect(self.del_split_row)
        split_buttons.addWidget(btn_add)
        split_buttons.addWidget(btn_del)
        split_buttons.addStretch()
        dt_layout.addLayout(split_buttons)

        self.dt_comment = QTextEdit()
        self.dt_comment.setPlaceholderText("Genel Not (opsiyonel)")
        self.dt_comment.setMinimumHeight(80)
        dt_layout.addWidget(self.dt_comment)

        content_layout.addWidget(self.dt_group)

        self.btn_save_event = QPushButton("Duraklamayı Kaydet")
        self.btn_save_event.clicked.connect(self.save_downtime)
        content_layout.addWidget(self.btn_save_event)

        filter_row = QHBoxLayout()
        filter_row.setSpacing(12)
        filter_row.addWidget(QLabel("Liste Filtresi:"))
        self.event_filter_line = QComboBox()
        self.event_filter_line.addItem("Hepsi")
        self.event_filter_line.addItems(LINES)
        self.event_filter_line.currentIndexChanged.connect(self.refresh_event_table)
        filter_row.addWidget(self.event_filter_line)
        filter_row.addStretch()
        content_layout.addLayout(filter_row)

        self.events_tbl = QTableWidget(0, 0)
        self.events_tbl.horizontalHeader().setSectionResizeMode(QHeaderView.Stretch)
        self.events_tbl.setMinimumHeight(220)
        content_layout.addWidget(self.events_tbl)

        self.events_lbl_summary = QLabel("")
        self.events_lbl_summary.setWordWrap(True)
        content_layout.addWidget(self.events_lbl_summary)

        summary_group = QGroupBox("Dağılım Özeti")
        summary_layout = QVBoxLayout(summary_group)
        summary_layout.setSpacing(12)
        summary_layout.setContentsMargins(12, 12, 12, 12)
        summary_controls = QHBoxLayout()
        summary_controls.setSpacing(12)
        self.events_summary_start = QDateEdit()
        self.events_summary_start.setCalendarPopup(True)
        self.events_summary_start.setDate(QDate.currentDate())
        self.events_summary_end = QDateEdit()
        self.events_summary_end.setCalendarPopup(True)
        self.events_summary_end.setDate(QDate.currentDate())
        btn_summary = QPushButton("Özeti Hesapla")
        btn_summary.clicked.connect(self.generate_event_summary)
        summary_controls.addWidget(QLabel("Başlangıç:"))
        summary_controls.addWidget(self.events_summary_start)
        summary_controls.addWidget(QLabel("Bitiş:"))
        summary_controls.addWidget(self.events_summary_end)
        summary_controls.addStretch()
        summary_controls.addWidget(btn_summary)
        summary_layout.addLayout(summary_controls)
        self.events_txt_summary = QTextEdit()
        self.events_txt_summary.setReadOnly(True)
        self.events_txt_summary.setPlaceholderText("Seçilen tarih aralığında dağılım özetleri burada listelenecek.")
        self.events_txt_summary.setMinimumHeight(120)
        summary_layout.addWidget(self.events_txt_summary)
        content_layout.addWidget(summary_group)

        report_group = QGroupBox("Günlük Üretim/Duraklama Raporu")
        report_layout = QVBoxLayout(report_group)
        report_layout.setSpacing(12)
        report_layout.setContentsMargins(12, 12, 12, 12)
        report_controls = QHBoxLayout()
        report_controls.setSpacing(12)
        self.events_report_date = QDateEdit()
        self.events_report_date.setCalendarPopup(True)
        self.events_report_date.setDate(QDate.currentDate())
        self.events_report_date.dateChanged.connect(lambda *_: self.generate_event_report())
        btn_update_report = QPushButton("Raporu Güncelle")
        btn_update_report.clicked.connect(self.generate_event_report)
        self.events_btn_mail = QPushButton("Mail ile Gönder")
        self.events_btn_mail.clicked.connect(self.mail_placeholder)
        report_controls.addWidget(QLabel("Tarih:"))
        report_controls.addWidget(self.events_report_date)
        report_controls.addWidget(btn_update_report)
        report_controls.addStretch()
        report_controls.addWidget(self.events_btn_mail)
        report_layout.addLayout(report_controls)
        self.events_txt_report = QTextEdit()
        self.events_txt_report.setReadOnly(True)
        self.events_txt_report.setPlaceholderText("Seçilen gün için üretim performansı ve aksaklık özeti burada görünecek.")
        self.events_txt_report.setMinimumHeight(140)
        report_layout.addWidget(self.events_txt_report)
        content_layout.addWidget(report_group)

        content_layout.addStretch()

        self.update_event_line_options()
        self.add_split_row()
        self.refresh_production_table()
        self.refresh_event_table()
        self.generate_event_report()
        self.generate_event_summary()

    def _sync_line_combo(self, combo, text):
        if combo is None:
            return
        idx = combo.findText(text)
        if idx >= 0 and combo.currentIndex() != idx:
            combo.blockSignals(True)
            combo.setCurrentIndex(idx)
            combo.blockSignals(False)

    def on_line_changed(self, text):
        self._sync_line_combo(self.ev_cmb_line, text)
        self._sync_line_combo(self.event_filter_line, text)
        self.refresh_production_table()
        self.refresh_event_table()
        self.generate_event_report()

    def on_event_line_changed(self, text):
        if self.cmb_line.currentText() != text:
            self.cmb_line.blockSignals(True)
            self.cmb_line.setCurrentText(text)
            self.cmb_line.blockSignals(False)
        self.on_line_changed(text)

    def save_production_record(self):
        line = self.cmb_line.currentText()
        date_str = self.date_edit.date().toString("yyyy-MM-dd")
        expected = self.spn_expected.value()
        actual = self.spn_actual.value()
        perf = 0.0 if expected == 0 else round((actual / expected) * 100, 2)
        comment = self.txt_comment.text().strip()

        conn = get_conn()
        cur = conn.cursor()
        existing = cur.execute(
            "SELECT id FROM productions WHERE line=? AND date=?",
            (line, date_str),
        ).fetchone()
        if existing:
            conn.close()
            QMessageBox.warning(
                self,
                "Kayıt Mevcut",
                "Seçilen bant ve tarih için zaten bir üretim kaydı bulunuyor.",
            )
            return
        cur.execute(
            "INSERT INTO productions(line,date,expected,actual,performance_pct,comment,created_at) VALUES(?,?,?,?,?,?,?)",
            (line, date_str, expected, actual, perf, comment, datetime.utcnow().isoformat()),
        )
        conn.commit()
        conn.close()
        self.refresh_production_table()
        if self.events_report_date.date() == self.date_edit.date():
            self.generate_event_report()
        QMessageBox.information(self, "Kayıt", "Üretim kaydı eklendi")

    def delete_selected_production(self):
        row = self.production_tbl.currentRow()
        if row < 0:
            QMessageBox.warning(
                self,
                "Seçim Yok",
                "Silmek için listeden bir üretim kaydı seçin.",
            )
            return

        id_item = self.production_tbl.item(row, 0)
        line_item = self.production_tbl.item(row, 1)
        date_item = self.production_tbl.item(row, 2)
        record_id_text = id_item.text().strip() if id_item else ""
        if not record_id_text:
            QMessageBox.warning(
                self,
                "Eksik Bilgi",
                "Seçilen kaydın kimlik bilgisi bulunamadı.",
            )
            return

        try:
            record_id = int(record_id_text)
        except ValueError:
            QMessageBox.warning(
                self,
                "Geçersiz Kayıt",
                "Seçilen kaydın kimlik bilgisi geçersiz.",
            )
            return

        confirm = QMessageBox.question(
            self,
            "Üretimi Sil",
            "Seçilen üretim kaydını silmek istediğinize emin misiniz?",
            QMessageBox.Yes | QMessageBox.No,
            QMessageBox.No,
        )
        if confirm != QMessageBox.Yes:
            return

        selected_line = line_item.text().strip() if line_item else ""
        selected_date = date_item.text().strip() if date_item else ""

        conn = get_conn()
        cur = conn.cursor()
        deleted = 0

        try:
            cur.execute("DELETE FROM productions WHERE id=?", (record_id,))
            deleted = cur.rowcount

            if deleted and selected_line and selected_date:
                downtime_ids = [
                    row["id"]
                    for row in cur.execute(
                        "SELECT id FROM downtimes WHERE line=? AND date=?",
                        (selected_line, selected_date),
                    ).fetchall()
                ]
                if downtime_ids:
                    cur.executemany(
                        "DELETE FROM downtime_splits WHERE downtime_id=?",
                        [(downtime_id,) for downtime_id in downtime_ids],
                    )
                    cur.execute(
                        "DELETE FROM downtimes WHERE id IN (%s)" % ",".join(["?"] * len(downtime_ids)),
                        downtime_ids,
                    )

            conn.commit()
        finally:
            conn.close()

        if not deleted:
            QMessageBox.warning(
                self,
                "Bulunamadı",
                "Seçilen üretim kaydı veritabanında bulunamadı.",
            )
            return

        self.refresh_production_table()
        self.refresh_event_table()

        if selected_date:
            report_date = self.events_report_date.date().toString("yyyy-MM-dd")
            if selected_date == report_date:
                self.generate_event_report()

            summary_start = self.events_summary_start.date().toString("yyyy-MM-dd")
            summary_end = self.events_summary_end.date().toString("yyyy-MM-dd")
            if summary_start <= selected_date <= summary_end:
                self.generate_event_summary()

        QMessageBox.information(
            self,
            "Silindi",
            "Üretim kaydı ve ilgili duraklama kayıtları silindi.",
        )

    def refresh_production_table(self):
        line = self.cmb_line.currentText()
        conn = get_conn()
        cur = conn.cursor()
        cur.execute(
            "SELECT id,line,date,expected,actual,performance_pct,comment FROM productions WHERE line=? ORDER BY date DESC, id DESC LIMIT 20",
            (line,),
        )
        rows = cur.fetchall()

        headers = [
            "id",
            "Bant",
            "Tarih",
            "Beklenen",
            "Gerçekleşen",
            "Performans %",
            "Duraklama Süresi (dk)",
            "Duraklama Detayı",
            "Yorum",
        ]
        self.production_tbl.setColumnCount(len(headers))
        self.production_tbl.setHorizontalHeaderLabels(headers)
        self.production_tbl.setRowCount(0)

        for row in rows:
            downtime_total, downtime_details = self._fetch_downtime_summary(conn, row["line"], row["date"])
            idx = self.production_tbl.rowCount()
            self.production_tbl.insertRow(idx)
            values = [
                str(row["id"]),
                row["line"],
                row["date"],
                str(row["expected"]),
                str(row["actual"]),
                str(row["performance_pct"]),
                str(downtime_total),
                downtime_details,
                row["comment"] or "",
            ]
            for col, value in enumerate(values):
                item = QTableWidgetItem(value)
                if col in (7, 8) and value:
                    item.setToolTip(value)
                self.production_tbl.setItem(idx, col, item)

        conn.close()
        self.production_tbl.viewport().update()
        self.clear_production_detail_preview()

    def clear_production_detail_preview(self):
        self.production_detail_title.setText("Detay Seçiniz")
        self.production_detail_view.clear()

    def on_production_cell_clicked(self, row, column):
        if column not in (7, 8):
            self.clear_production_detail_preview()
            return

        item = self.production_tbl.item(row, column)
        if not item:
            self.clear_production_detail_preview()
            return

        text = item.text().strip()
        if not text:
            self.clear_production_detail_preview()
            return

        header_item = self.production_tbl.horizontalHeaderItem(column)
        header_text = header_item.text() if header_item else "Detay"
        self.production_detail_title.setText(header_text)
        self.production_detail_view.setPlainText(text)

    def _fetch_downtime_summary(self, conn, line, date_str):
        cur = conn.cursor()
        cur.execute(
            "SELECT SUM(total_minutes) AS total FROM downtimes WHERE line=? AND date=?",
            (line, date_str),
        )
        total_row = cur.fetchone()
        total = total_row["total"] if total_row and total_row["total"] is not None else 0

        cur.execute(
            """
            SELECT ds.department, ds.reason, ds.minutes, ds.note
            FROM downtime_splits ds
            JOIN downtimes d ON d.id = ds.downtime_id
            WHERE d.line = ? AND d.date = ?
            ORDER BY d.start_time, ds.id
            """,
            (line, date_str),
        )
        rows = cur.fetchall()
        details = []
        for r in rows:
            text = f"{r['department']} - {r['reason']} ({r['minutes']} dk)"
            if r["note"]:
                text += f" Not: {r['note']}"
            details.append(text)
        return total, "; ".join(details)

    def update_event_line_options(self):
        """Keep event-related line selections aligned with the production line."""
        current_line = self.cmb_line.currentText()
        if current_line:
            self._sync_line_combo(self.ev_cmb_line, current_line)
            self._sync_line_combo(self.event_filter_line, current_line)

    def add_split_row(self):
        idx = self.dt_tbl_split.rowCount()
        self.dt_tbl_split.insertRow(idx)
        self.dt_tbl_split.setItem(idx, 0, QTableWidgetItem(DEPARTMENTS[0]))
        self.dt_tbl_split.setItem(idx, 1, QTableWidgetItem(REASONS[0]))
        self.dt_tbl_split.setItem(idx, 2, QTableWidgetItem("0"))
        self.dt_tbl_split.setItem(idx, 3, QTableWidgetItem(""))

    def del_split_row(self):
        row = self.dt_tbl_split.currentRow()
        if row >= 0:
            self.dt_tbl_split.removeRow(row)

    def save_downtime(self):
        total = self.dt_total.value()
        sum_rows = 0
        splits = []
        for i in range(self.dt_tbl_split.rowCount()):
            dept_item = self.dt_tbl_split.item(i, 0)
            reason_item = self.dt_tbl_split.item(i, 1)
            mins_item = self.dt_tbl_split.item(i, 2)
            note_item = self.dt_tbl_split.item(i, 3)
            dept = dept_item.text() if dept_item else ""
            reason = reason_item.text() if reason_item else ""
            mins_text = mins_item.text() if mins_item else "0"
            note = note_item.text() if note_item else ""
            try:
                mins = int(mins_text)
            except ValueError:
                QMessageBox.warning(self, "Hata", f"Geçersiz dakika: satır {i + 1}")
                return
            sum_rows += mins
            splits.append((reason, dept, mins, note))

        if sum_rows != total:
            QMessageBox.warning(self, "Doğrulama", f"Toplam ({total}) ile satırların toplamı ({sum_rows}) eşit değil")
            return

        line = self.ev_cmb_line.currentText()
        date_str = self.ev_date.date().toString("yyyy-MM-dd")
        start = self.dt_start_time.text().strip() or "00:00"
        comment = self.dt_comment.toPlainText().strip()

        conn = get_conn()
        cur = conn.cursor()
        existing = cur.execute(
            "SELECT id FROM downtimes WHERE line=? AND date=?",
            (line, date_str),
        ).fetchone()
        if existing:
            conn.close()
            QMessageBox.warning(
                self,
                "Kayıt Mevcut",
                "Seçilen bant ve tarih için zaten bir duraklama kaydı bulunuyor.",
            )
            return
        cur.execute(
            "INSERT INTO downtimes(line,date,start_time,total_minutes,comment,created_at) VALUES(?,?,?,?,?,?)",
            (line, date_str, start, total, comment, datetime.utcnow().isoformat()),
        )
        dt_id = cur.lastrowid
        cur.executemany(
            "INSERT INTO downtime_splits(downtime_id,reason,department,minutes,note) VALUES(?,?,?,?,?)",
            [(dt_id, r, d, m, n) for (r, d, m, n) in splits],
        )
        conn.commit()
        conn.close()

        self.events_report_date.setDate(self.ev_date.date())
        self.events_summary_start.setDate(self.ev_date.date())
        self.events_summary_end.setDate(self.ev_date.date())
        self.refresh_event_table()
        self.refresh_production_table()
        self.generate_event_report()
        self.generate_event_summary()

        self.dt_start_time.clear()
        self.dt_tbl_split.setRowCount(0)
        self.add_split_row()
        self.dt_comment.clear()
        QMessageBox.information(self, "Kayıt", "Duraklama kaydedildi")

    def refresh_event_table(self):
        conn = get_conn()
        cur = conn.cursor()
        line_filter = self.event_filter_line.currentText()

        entries = []
        total_dt = 0

        sql = "SELECT id,line,date,start_time,total_minutes,comment,created_at FROM downtimes"
        params = []
        if line_filter != "Hepsi":
            sql += " WHERE line=?"
            params.append(line_filter)
        sql += " ORDER BY date DESC, created_at DESC LIMIT 50"
        cur.execute(sql, params)
        downtimes = cur.fetchall()
        for dt in downtimes:
            total_dt += dt["total_minutes"]
            splits = conn.execute(
                "SELECT department,reason,minutes FROM downtime_splits WHERE downtime_id=?",
                (dt["id"],),
            ).fetchall()
            split_text = "; ".join(
                f"{sp['department']} - {sp['reason']} ({sp['minutes']} dk)" for sp in splits
            )
            entries.append([
                str(dt["id"]),
                dt["line"],
                dt["date"],
                dt["start_time"],
                str(dt["total_minutes"]),
                split_text,
                dt["comment"] or "",
                dt["created_at"],
            ])

        conn.close()

        headers = [
            "id",
            "Bant",
            "Tarih",
            "Başlangıç",
            "Süre (dk)",
            "Detay",
            "Not",
            "Kaydedildi",
        ]
        self.events_tbl.setColumnCount(len(headers))
        self.events_tbl.setHorizontalHeaderLabels(headers)
        self.events_tbl.setRowCount(0)

        for entry in entries:
            idx = self.events_tbl.rowCount()
            self.events_tbl.insertRow(idx)
            for col, value in enumerate(entry):
                text = "" if value is None else str(value)
                item = QTableWidgetItem(text)
                item.setToolTip(text)
                self.events_tbl.setItem(idx, col, item)

        self.events_tbl.resizeRowsToContents()
        if entries:
            self.events_lbl_summary.setText(f"Gösterilen duraklama süresi → {total_dt} dk")
        else:
            self.events_lbl_summary.setText("")

    def generate_event_report(self):
        date_str = self.events_report_date.date().toString("yyyy-MM-dd")
        line_filter = (
            self.event_filter_line.currentText() if self.event_filter_line else "Hepsi"
        )

        conn = get_conn()
        cur = conn.cursor()

        prod_sql = (
            "SELECT line, expected, actual, performance_pct, comment FROM productions WHERE date=?"
        )
        prod_params = [date_str]
        if line_filter != "Hepsi":
            prod_sql += " AND line=?"
            prod_params.append(line_filter)
        prod_sql += " ORDER BY line"
        cur.execute(prod_sql, prod_params)
        productions = cur.fetchall()

        dt_sql = "SELECT id,line,start_time,total_minutes,comment FROM downtimes WHERE date=?"
        dt_params = [date_str]
        if line_filter != "Hepsi":
            dt_sql += " AND line=?"
            dt_params.append(line_filter)
        dt_sql += " ORDER BY line"
        cur.execute(dt_sql, dt_params)
        downtimes = cur.fetchall()

        splits_cache = {}
        for dt in downtimes:
            rows = conn.execute(
                "SELECT department, reason, minutes, note FROM downtime_splits WHERE downtime_id=?",
                (dt["id"],),
            ).fetchall()
            details = []
            for row in rows:
                text = f"{row['department']} - {row['reason']} ({row['minutes']} dk)"
                if row["note"]:
                    text += f" Not: {row['note']}"
                details.append(text)
            splits_cache[dt["id"]] = details

        conn.close()

        lines = sorted(
            {row["line"] for row in productions}
            | {row["line"] for row in downtimes}
        )
        report_lines = [f"Rapor Tarihi: {date_str}", ""]

        total_dt = sum(dt["total_minutes"] for dt in downtimes)
        performances = [row["performance_pct"] for row in productions]
        if lines:
            summary_parts = []
            if downtimes:
                summary_parts.append(f"Duraklama: {total_dt} dk")
            if summary_parts:
                report_lines.append(
                    "Genel Süreler → " + ", ".join(summary_parts)
                )
            if performances:
                avg_perf = round(sum(performances) / len(performances), 2)
                report_lines.append(f"Ortalama Performans: %{avg_perf}")
            report_lines.append("")
        else:
            if line_filter != "Hepsi":
                report_lines.append("Seçilen filtrelere uygun kayıt bulunamadı.")
            else:
                report_lines.append("Seçilen tarihte kayıt bulunamadı.")

        prod_by_line = {row["line"]: row for row in productions}
        dt_by_line = {}
        for dt in downtimes:
            dt_by_line.setdefault(dt["line"], []).append(dt)
        for line in lines:
            report_lines.append(f"{line}:")
            prod = prod_by_line.get(line)
            if prod:
                base = f"  Üretim → Beklenen: {prod['expected']}, Gerçekleşen: {prod['actual']}, Performans: %{prod['performance_pct']}"
                if prod["comment"]:
                    base += f" | Not: {prod['comment']}"
                report_lines.append(base)
            else:
                report_lines.append("  Üretim kaydı bulunmuyor.")

            line_dts = dt_by_line.get(line, [])
            if line_dts:
                report_lines.append("  Duraklamalar:")
                total_line_dt = 0
                for dt in line_dts:
                    entry = f"    - Başlangıç: {dt['start_time']} | Süre: {dt['total_minutes']} dk"
                    if dt["comment"]:
                        entry += f" | Not: {dt['comment']}"
                    report_lines.append(entry)
                    total_line_dt += dt["total_minutes"]
                    details = splits_cache.get(dt["id"], [])
                    if details:
                        report_lines.append("      Dağılım: " + "; ".join(details))
                report_lines.append(f"  Toplam Duraklama: {total_line_dt} dk")
            else:
                report_lines.append("  Duraklama kaydı yok.")

            report_lines.append("")

        if not lines:
            message = "Üretim veya duraklama kaydı bulunamadı."
            if line_filter != "Hepsi":
                message = "Seçilen filtrelere uygun kayıt bulunamadı."
            report_lines = [
                f"Rapor Tarihi: {date_str}",
                "",
                message,
            ]

        self.events_txt_report.setPlainText("\n".join(report_lines))

    def generate_event_summary(self):
        if self.events_summary_start.date() > self.events_summary_end.date():
            QMessageBox.warning(self, "Tarih Aralığı", "Başlangıç tarihi bitişten büyük olamaz.")
            return

        start_date = self.events_summary_start.date().toString("yyyy-MM-dd")
        end_date = self.events_summary_end.date().toString("yyyy-MM-dd")
        conn = get_conn()
        cur = conn.cursor()
        cur.execute(
            """
            SELECT department, reason, SUM(minutes) AS total
            FROM downtime_splits
            JOIN downtimes ON downtimes.id = downtime_splits.downtime_id
            WHERE downtimes.date BETWEEN ? AND ?
            GROUP BY department, reason
            ORDER BY total DESC
            """,
            (start_date, end_date),
        )
        dt_rows = cur.fetchall()

        conn.close()

        total_dt = sum(row["total"] for row in dt_rows)

        if not dt_rows:
            self.events_txt_summary.setPlainText("Seçilen aralıkta duraklama kaydı bulunamadı.")
            return

        lines = [
            f"Tarih Aralığı: {start_date} - {end_date}",
            f"Toplam Duraklama Süresi: {total_dt} dk",
            "",
            "Duraklama Dağılımı:",
        ]

        for row in dt_rows:
            share = 0 if total_dt == 0 else round((row["total"] / total_dt) * 100, 1)
            lines.append(f"- {row['department']} / {row['reason']}: {row['total']} dk (%{share})")

        self.events_txt_summary.setPlainText("\n".join(lines))

    def mail_placeholder(self):
        QMessageBox.information(
            self,
            "Mail Gönderimi",
            "Mail gönderme planlama özelliği yakında eklenecek.",
        )




class HistoryTab(QWidget):
    def __init__(self):
        super().__init__()
        layout = QVBoxLayout(self)
        # Basit filtreler: Bant ve kayıt türü
        row = QHBoxLayout()
        self.cmb_line = QComboBox(); self.cmb_line.addItem("Hepsi"); self.cmb_line.addItems(LINES)
        self.cmb_type = QComboBox(); self.cmb_type.addItems(["Üretim","Duraklama"])
        btn_refresh = QPushButton("Yenile"); btn_refresh.clicked.connect(self.refresh)
        row.addWidget(QLabel("Bant:")); row.addWidget(self.cmb_line)
        row.addWidget(QLabel("Tür:")); row.addWidget(self.cmb_type)
        row.addWidget(btn_refresh); row.addStretch()
        layout.addLayout(row)

        self.tbl = QTableWidget(0, 0)
        self.tbl.horizontalHeader().setSectionResizeMode(QHeaderView.Stretch)
        layout.addWidget(self.tbl)
        self.refresh()

    def refresh(self):
        typ = self.cmb_type.currentText()
        line = self.cmb_line.currentText()
        conn = get_conn(); cur = conn.cursor()
        if typ == "Üretim":
            sql = "SELECT id,line,date,expected,actual,performance_pct,comment,created_at FROM productions"
            order_clause = " ORDER BY id DESC LIMIT 100"
        elif typ == "Duraklama":
            sql = "SELECT id,line,date,start_time,total_minutes,comment,created_at FROM downtimes"
            order_clause = " ORDER BY id DESC LIMIT 100"
        else:
            sql = "SELECT id,line,date,start_time,total_minutes,comment,created_at FROM downtimes"
            order_clause = " ORDER BY id DESC LIMIT 100"

        params = []
        if line != "Hepsi":
            sql += " WHERE line=?"
            params.append(line)
        sql += order_clause
        cur.execute(sql, params)
        rows = cur.fetchall(); conn.close()

        # Başlıklar
        headers = list(rows[0].keys()) if rows else []
        if not headers:
            if typ == "Üretim":
                headers = ["id","line","date","expected","actual","performance_pct","comment","created_at"]
            elif typ == "Duraklama":
                headers = ["id","line","date","start_time","total_minutes","comment","created_at"]
            else:
                headers = ["id","line","date","start_time","total_minutes","comment","created_at"]
        self.tbl.setColumnCount(len(headers))
        self.tbl.setHorizontalHeaderLabels(headers)
        self.tbl.setRowCount(0)
        for r in rows:
            i = self.tbl.rowCount(); self.tbl.insertRow(i)
            row_data = dict(r)
            for j, h in enumerate(headers):
                value = row_data.get(h, "")
                if value is None:
                    value = ""
                self.tbl.setItem(i, j, QTableWidgetItem(str(value)))


class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("Fabrika İzleme • Desktop (PySide6)")
        self.resize(1100, 700)
        tabs = QTabWidget()
        tabs.addTab(ProductionTab(), "Üretim & Duraklamalar")
        tabs.addTab(HistoryTab(), "Geçmiş")
        self.setCentralWidget(tabs)

        # Menü → Çıkış ve Hakkında
        menu = self.menuBar().addMenu("Dosya")
        act_exit = QAction("Çıkış", self); act_exit.triggered.connect(self.close)
        menu.addAction(act_exit)
        helpm = self.menuBar().addMenu("Yardım")
        about = QAction("Hakkında", self); about.triggered.connect(self.show_about)
        helpm.addAction(about)

    def show_about(self):
        QMessageBox.information(self, "Hakkında", "Fabrika İzleme Desktop MVP\nPySide6 + SQLite\n© 2025")


def main():
    app = QApplication(sys.argv)

    login = LoginDialog()
    if login.exec() != QDialog.Accepted:
        return

    init_db()
    win = MainWindow()
    win.show()
    sys.exit(app.exec())


if __name__ == "__main__":
    main()
